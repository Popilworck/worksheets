\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage{amsmath}
\usepackage{hyperref}

\title{ECE220 Midterm 1 Review}
\author{Author: Members of HKN}
\date{Fall 2024}

\newcommand{\dd}[1]{\mathrm{d}#1}

\usepackage[makeroom]{cancel}
\usepackage[letterpaper, portrait, margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{multirow}



\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{1,1,1}
\newcommand{\wideunderscore}{\underline{\hphantom{n}}}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C,
    escapechar=\@
}

\pagenumbering{arabic}

\begin{document}

\maketitle

\section {
Memory-Mapped I/O
}


\begin{enumerate}[label=(\alph*)]
    \item What is the difference between a callee-saved and a caller-saved register?
    \newline
    \newline
    \newline
    \newline
    \newline
   

    \item What is the difference between polling I/O vs. Interrupt-Driven I/O?
    \newline
    \newline
    \newline
    \newline
    \newline

    \item Fill in the blanks of the following statements relating to Memory-Mapped I/O.

    Certain device registers are \wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore to certain \wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore locations. However, the registers physically are \wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore from the memory. Memory-mapped device registers are a common way to \wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore\wideunderscore computer systems with devices.

    

    
\end{enumerate}


\section{
    Traps and Subroutines
}

\begin{enumerate}[label=(\alph*)]

\item Why would we need to have service routines (known as TRAPs)? Name three reasons.
\newline
\newline
\newline
\newline
\newline
\newline


    \item \textbf{Shifting :(}

    Write a subroutine that performs a logical left shift of R1 by the value stored in R2, and reports the result in R1. You may assume that R2 contains a positive number. Only R6 and R1 can be modified/read from, and only R2 can be read from.
    \newpage
    \textcolor{purple}{.ORIG x3100}
    \newline
    \textcolor{purple}{SHIFTL}
    \newline
    \textcolor{gray}{; code starts here}
    \newline
    \newline
    \newline
    \newline
    \newline
    \newline
    \newline
    \newline
    \textcolor{gray}{; code ends here}
    \newline
    \textcolor{purple}{RET}

    \textcolor{purple}{.END}



    \item  \textbf{Permute Quarters}:

   A value stored in a 16-bit LC3 register can be divided into four equal parts of four bits each:
    \begin{center}
        $X = $ $X_1$ $X_2$ $X_3$ $X_4$ \\
    \end{center}
Write a subroutine, PERMUTE, that reorders R5 as follows:
\begin{center}
R5 = $X_1$ $X_3$ $X_2$ $X_4$    
\end{center}

Assume all registers are caller-saved. You should not use loops. You may assume the existence of a DIV subroutine, which divides as expected. There are also some labels for you to use. [Hint: the previous subroutine might be useful]

\textcolor{purple}{.ORIG x3100}

    \textcolor{gray}{; assume code for entry point is omitted}\\
    \textcolor{gray}{;}\\
    \textcolor{gray}{;}\\
    \textcolor{gray}{;}\\

    \textcolor{purple}{PERMUTE} \newline
    \textcolor{gray}{; write the code here}
    \\
    \\
    \\
    \\
    \\
    \\
    \\
    \\
    \\
    \\
    \textcolor{gray}{; code ends here}
    
    \textcolor{purple}{RET}
    \newline \textcolor{gray}{; code omitted}
    \newline    \textcolor{gray}{;}
    \newline \textcolor{purple}{.HALT}
    \textcolor{gray}{; labels below}
    \newline
    \textcolor{purple}{CLEARX2X3 .FILL \#0xF00F}
    \newline
    \textcolor{purple}{FOUR .FILL \#4}
    \newline
    \textcolor{purple}{X2 .FILL 0x0F00}
    \newline
    \textcolor{purple}{X3 .FILL 0x00F0}
    \newline
    \textcolor{purple}{SAVER7 .FILL \#0}
    \newline
    \textcolor{purple}{.END}
    
\item \textbf{Trap Concepts}

Given the figures below, determine the memory address of the TRAP vector table that will be accessed and which TRAP service routine will be executed.
\newline

\begin{center}

\begin{tabular}{||c  ||} 
\hline
\multicolumn{1}{|c|}{User Program ASM Code} \\
 \hline
 ;   \\ 
 \hline
;  \\ 
 \hline
 TRAP 0xAA \\
 \hline
 ;\\
 \hline
 ;  \\
 \hline
 
\end{tabular}

\begin{tabular}{|p{3cm} p{3cm} |} 
\hline
 Address & Value  \\ [0.5ex] 
 \hline\hline
 0xAA & 0x05C0 \\ 
 \hline
 0x1AA & 0x05D0 \\
 \hline
 0x2AA & 0x05E0 \\
 \hline
 0x3AA & 0x05F0 \\
 \hline
 ... &  \\ [1ex]
 \hline
  & \\ [1ex]
  \hline
  0x05C0 & Routine $\alpha$ \\
  \hline
  0x05D0 & Routine $\omega$\\
  \hline
  0x35C0 & Routine $\kappa$ \\
  \hline
  0x35D0 & Routine $\pi$ \\
 \hline
 
\end{tabular}y




\end{center}

Trap Vector Table Entry:

\begin{enumerate}[label={}]
    \item a. 0xAA
    \item b. 0x1AA
    \item c. 0x2AA
    \item d. 0x3AA

    \end{enumerate}

Trap Routine Executed:

\begin{enumerate}[label={}]
    \item a. $\alpha$ 
    \item b. $\omega$
    \item c. $\kappa$
    \item d. $\pi$
\end{enumerate}

Of the following steps executed during a TRAP, in what order are they executed?
\begin{enumerate}[label={}]
    
\item a. Return to User Program
\item b. Execute Trap Routine
\item c. Access Trap Vector Table
\newline
\item 1)
\item 2)
\item 3)

\end{enumerate}
\end{enumerate}
\section{Stack Operations}
\begin{enumerate}[label=(\alph*)]
    \item Given the following input sequence of numbers: “24609846117”, write a sequence of pushes and pops that produces this output: “64098116472”.

    \item Two Parts:
    \begin{enumerate}[label=()]
        \item[i.] Write the expression    $(  ( (4 * 2) + 1 ) / 3) + 5$ in postfix notation.
        \item[ii.] Write the following postfix expressions in mathematical notation and indicate what they evaluate to (if they are not valid, write “not valid”)
        \begin{enumerate}
            \item[*] 6721*-5/* \newline
            \item[*] 83+632-+1*+- \newline
            \item[*] 2233*2+5-+8/- \newline
            \item[*] 89+6-44 \newline
        \end{enumerate}
    \end{enumerate}


    \item \textbf{MP2 Postfix Calculator:} This sequence is input to the console: 445+3/8*-= Draw the stack (and where the stack pointer points to) after:

    \begin{enumerate}
        \item[i.] 5 has been input
        \item[ii.] + has been input
        \item[iii.] * has been input
        \item[iv.] = has been input
    \end{enumerate}
    Assume that the stack pointer points to the address \textbf{one above the most recent-pushed entry.} Remember that a POP does NOT remove an item from memory but simply changes the stack pointer!
    \newpage
 
\end{enumerate}
\section{C Programming}
\begin{enumerate}
    \item[(a)] What will be the output of the following C Program?
    \begin{lstlisting}[style=CStyle]
int main() {
	int i;
	for (i = 3; i < 13; i ++ )
	{
		if (i % 3 == 1)
		{
			printf("Bong\n");	  		
            }
		if (i % 2 == 0)
		{
			printf("Ding\n");
			continue;
		}
		printf("Odd\n");
		
	}
	return 0;
}
    \end{lstlisting}
    \item[(b)] What is the return value of this program?
    \begin{lstlisting}[style=CStyle]
int foo(int x, int y);

int main()
{
	int x = 3;
	int y = 4;

	x = y + foo(x,y); 
	y = x - foo(x,y); 
			
	return x + y;



}

int foo(int x, int y)
{
	int a = x + y;
	int b= x - y;
	a += x--;
	y ++;
	a += (y + 1);
	return b + a + --x;


}

    \end{lstlisting}
    

\end{enumerate}
\section{Conceptual Questions}

\begin{enumerate}[label=(\alph*)]
    \item What is the order of access for a stack abstract data type?
\newline
        \newline
        \newline
    \item Define overflow and underflow.
\newline
        \newline
        \newline
    \item True or False. Please explain your answer.
    \begin{enumerate}[label=\roman*.]
        \item Interrupts are more efficient than polling.
        \newline
        \newline
        \newline
        \item There are up to 8 possible TRAP service routines.
        \newline
        \newline
        \newline
        \item TRAPs shield programmers from system specific details.
        \newline
        \newline
        \newline
        \item PSR and PC are pushed to the User stack before executing an interrupt service routine.
        \newline
        \newline
        \newline
        \item An item is deleted after being pushed off the stack.
        \newline
        \newline
        \newline
        \item TRAP service routines are provided as part of the system code.

    \end{enumerate}
\end{enumerate}



\end{document}